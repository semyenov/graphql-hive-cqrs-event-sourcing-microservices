overwrite: true
config:
  # Global configuration for maximum type safety
  strict: true
  skipTypename: false
  exportFragmentSpreadSubTypes: true
  dedupeFragments: true
  inlineFragmentTypes: 'combine'
  preResolveTypes: true
  namingConvention:
    typeNames: 'pascal-case#pascalCase'
    enumValues: 'upper-case#upperCase'
    fieldNames: 'camelCase'
    
generates:
  # Unified schema types
  src/types/generated/schema.ts:
    schema: src/schema.graphql
    plugins:
      - typescript
    config:
      enumsAsTypes: true
      constEnums: true
      numericEnums: false
      nonOptionalTypename: true
      scalars:
        ID: 
          input: 'import("../branded").AggregateId'
          output: 'import("../branded").AggregateId'
        String: string
        Int: number
        Float: number
        Boolean: boolean
      avoidOptionals:
        field: true
        inputValue: false
        object: false
        defaultValue: false
      maybeValue: 'T | null | undefined'
      inputMaybeValue: 'T | null | undefined'
      immutableTypes: true
      
  # Resolver types with strict domain mapping
  src/types/generated/resolvers.ts:
    schema: src/schema.graphql
    plugins:
      - typescript
      - typescript-resolvers
    config:
      enumsAsTypes: true
      useIndexSignature: false  # Disable index signatures for stricter typing
      strictScalars: true
      contextType: 'import("../../server").GraphQLContext'
      rootValueType: 'import("../../server").GraphQLRootValue'
      scalars:
        ID:
          input: 'import("../branded").AggregateId'
          output: 'import("../branded").AggregateId'
        String: string
        Int: number
        Float: number
        Boolean: boolean
      avoidOptionals:
        field: true
        inputValue: false
        object: false
        defaultValue: false
      maybeValue: 'T | null | undefined'
      inputMaybeValue: 'T | null | undefined'
      immutableTypes: true
      # Enhanced domain mappers
      mappers:
        # Map GraphQL types to domain models
        User: 'import("../../models/User").UserModel'
        CreateUserInput: 'import("../../events/generic-types").ExtractEventData<import("../../events/generic-types").UserCreatedEvent>'
        UpdateUserInput: 'import("../../events/generic-types").ExtractEventData<import("../../events/generic-types").UserUpdatedEvent>'
        # Error handling with simple GraphQL error type
        Error: 'import("../graphql-error-adapter").SimpleGraphQLError'
      # Type-safe resolver signatures
      defaultMapper: 'Partial<{T}>'
      
  # Command type generation for write operations
  src/types/generated/commands.ts:
    schema: src/schema.graphql
    plugins:
      - typescript
      - add:
          content: |
            // Auto-generated command types for CQRS
            import type { Command, CommandResult } from '../../events/generic-types';
            import type { AggregateId } from '../branded';
            import type { UserEvent } from '../../events/generic-types';
            
    config:
      enumsAsTypes: true
      scalars:
        ID: 'import("../branded").AggregateId'
      customResolverFn: |
        (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) =>
          Promise<CommandResult<TResult>> | CommandResult<TResult>
          
  # Query projection types for read operations
  src/types/generated/projections.ts:
    schema: src/schema.graphql
    plugins:
      - typescript
      - add:
          content: |
            // Auto-generated projection types for CQRS read models
            import type { Projection, MaterializedView } from '../../events/generic-types';
            import type { UserEvent } from '../../events/generic-types';
            
    config:
      enumsAsTypes: true
      scalars:
        ID: 'import("../branded").AggregateId'
      customResolverFn: |
        (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) =>
          Promise<TResult> | TResult